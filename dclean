#!/bin/bash

# main program
# -d directory (mandatory)
# -o order criterion. must be one of: atime, mtime, ctime, size (default size)

source `dirname $0`/lib-dclean
order=size
while getopts "d:o:" OPTION
do
	case $OPTION in
	d)
		dir=$OPTARG
		;;
	o)
		order=$OPTARG
		;;
	esac

done

[ -z "$dir" -o ! -r "$dir" -o ! -d "$dir" ] && die_error "-d must be a readable directory. not: $dir"

orders=(atime mtime ctime size)
check_is_in $order "${orders[@]}" || die_error "-o must be one of: $orders (defaults to size). not: $order"

is_svn $dir    && type=svn    && echo "detected svn dir"
is_git $dir    && type=git    && echo "detected git dir"
[ -z "$type" ] && type=normal && echo "detected non-vcs dir"

# find is great because of its good conditionals, but lacks support for ordering
# ls is good for ordering files, but has no conditionals
# the following trick gives us what we need, albeit not the most efficient.

var_size=s # bytes
var_atime=X
var_mtime=Y
var_ctime=Z
variable=var_$order
var=${!variable}

sort_order= # small -> big (oldest first)
if [ $order == size ]
then
	sort_order='-r' # big -> small (bigger files first)
fi

OLD_IFS=$IFS
IFS=$'\n'
for i in `find "$dir" -maxdepth 1 -exec stat -c "%$var %n" {} + | sort -n $sort_order | sed 's/[^ ]* //'`
do
	#TODO printf with nice columns
	echo -n "$i .."
	state=
	if [ $type == svn ]
	then
		[[ $i =~ /.svn$ ]] && continue
		status=$(svn status "$i")
		if [[ -n "$status" && $status != I* ]]
		then
			echo "dirty"
		else
			echo "clean"
			continue
		fi
	elif [ $type == git ]
	then
		#TODO
		echo "warning. git not supported yet. treating as unversioned (no optimisations)" #not skipping anything even if they are clean in git
	else
		echo
	fi
	if [ ! -r "$i" ]
	then
		echo "no read permissions. skipping.."
		continue
	fi
	dclean-item "$i" "$type"
	[ $? -eq 123 ] && exit 123
done
IFS=$OLD_IFS
